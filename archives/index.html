<!DOCTYPE html>

<html lang="cn">

<head>
  
  <title>Archive - 子慎 Blog</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="子慎 Blog">
<meta property="og:url" content="http://www.shimengjie.cc/archives/index.html">
<meta property="og:site_name" content="子慎 Blog">
<meta property="og:locale">
<meta property="article:author" content="shimengjie">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css?v=233" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1616312137562">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="shimengjie" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="shimengjie"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="shimengjie">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="shimengjie" alt="shimengjie">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>2</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 shimengjie
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2021/03/21/001/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="1" class="lazyload">
                    <h1>1</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年03月21日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
        </div>

        <article>
            
                <h1 id="基于Redis的分布式锁实现"><a href="#基于Redis的分布式锁实现" class="headerlink" title="基于Redis的分布式锁实现"></a>基于Redis的分布式锁实现</h1><table>
<thead>
<tr>
<th>日期</th>
<th>版本</th>
<th align="left">作者</th>
<th align="left">修改内容</th>
</tr>
</thead>
<tbody><tr>
<td>2020.04.06</td>
<td>1.0</td>
<td align="left">史梦杰</td>
<td align="left">初稿（单机redis分布式锁）</td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>锁是多线程并发和分布式下，保证数据一致性必不可少的机制。分布式多进程系统无法像单进程系统那样，把锁保存在共享的堆内存中，必须存储在一个所有进程都能访问到的地方。本文档介绍如何一步步构建一个基于Redis的分布式锁，先从最原始的版本开始，然后根据存在的问题进行调整，最后完成一个较为合理的分布式锁。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无论是单机多线程系统，还是分布式多进程系统，当存在多个请求同时修改某个共享变量时，需要有一个“标记数据”来表示“当前该数据是否正在被修改”，从而控制同一时刻只能有一个“请求”在修改共享变量，这个‘标记数据“就是<strong>锁</strong>。</p>
<p>在单机多线程系统中，锁可以保存在共享的堆内存中，对所有线程都可见；在分布式多进程中，不同的机器无法共享一个内存，因此只能把锁放置在一个对所有进程都可见的地方，比如可以共同访问的数据库、Redis、Zookeeper等等。本文档对基于Redis的分布式锁进行介绍。</p>
<p>分布式锁，是指在分布式的部署环境下，通过锁机制保证多客户端互斥地对共享资源进行访问。和单进程的多线程锁类似，必须满足以下特性：</p>
<ul>
<li>互斥性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取</li>
<li>无死锁（活性）：锁在一段有限的时间之后（即使持有它的客户端崩溃或其他意外事件），也会被释放（正常释放或异常释放）</li>
<li>高可用（容错）：只要大部分Redis节点都活着，客户端就可以获取和释放锁</li>
</ul>
<p>下面我们将介绍基于Redis的分布式锁实现过程。</p>
<h2 id="单机Redis实现方案"><a href="#单机Redis实现方案" class="headerlink" title="单机Redis实现方案"></a>单机Redis实现方案</h2><h3 id="版本V1"><a href="#版本V1" class="headerlink" title="版本V1"></a>版本V1</h3><p>任何基于Redis的分布式锁，都包括<code>获取和释放</code>两个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁，并至多等待timeout时长</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key     锁的key值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 尝试获取锁的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value   锁的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, String value, Duration timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> timeoutMills = timeout.toMillis();</span><br><span class="line">    <span class="keyword">long</span> EXPIRE = <span class="number">5000L</span>; <span class="comment">// 锁的过期时间5秒</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(stringRedisTemplate.opsForValue().setIfAbsent(key, value), <span class="keyword">true</span>)) &#123;</span><br><span class="line">            stringRedisTemplate.expire(key, EXPIRE, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - current &gt; timeoutMills) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是最简单的版本：</p>
<ul>
<li>通过命令<code>SETNX</code>给一个key设置指定的value值，如果该key已经存在，就会设置失败，进行重试，直到重试超时；如果该key不存在，就能够设置成功。之所以给key设置一个过期时间，是防止客户端A获取锁后崩溃，导致锁无法释放，其他客户端无法获取锁。</li>
<li>释放锁时，删除对应的key。</li>
</ul>
<p>这个版本存在一个问题：当客户端A设置了key的value后，在设置过期时间之前崩溃了，那么锁将一直无法过期，其他客户端用户无法获取锁。这是因为在该版本中，“设置key值”和“设置过期时间”这两步是非原子的。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="E:\Document\文档\Figures\文档-F-003-01.png" alt="image-20200406230913808" class="lazyload"></p>
<h3 id="版本V2"><a href="#版本V2" class="headerlink" title="版本V2"></a>版本V2</h3><p>针对上<code>版本V1</code>中的问题，我们使用<code>SET KEY VALUE NX PX milliseconds</code>来原子性地设置key值和过期时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, String value, Duration timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> timeoutMills = timeout.toMillis();</span><br><span class="line">    <span class="keyword">long</span> EXPIRE = <span class="number">5000L</span>; <span class="comment">// 锁的过期时间5秒</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 原子地设置key值和过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(stringRedisTemplate.opsForValue().setIfAbsent(key, value, EXPIRE, TimeUnit.MILLISECONDS), <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - current &gt; timeoutMills) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Redis官方文档中介绍，<code>SETNX</code>命令会在后续版本中被遗弃，所以尽可能使用<code>SET key value NX PX milliseconds</code>命令实现原子性操作。</p>
<p>我们再看释放锁的过程，这时又出现一个问题，问题出现的步骤如下</p>
<ol>
<li>客户端A获取锁成功，过期时间30秒</li>
<li>客户端A在某个操作上阻塞了50秒</li>
<li>30秒时间到了，锁自动释放了</li>
<li>客户端B获取到了对应同一个资源的锁</li>
<li>客户端A从阻塞中恢复过来，释放掉了客户端B持有的锁</li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="E:\Document\文档\Figures\文档-F-003-02.png" alt="image-20200406232437449" class="lazyload"></p>
<p>之所以会出现客户端误删非自己持有的分布式锁，是因为释放锁的代码中，没有对锁的内容进行校验。可以为当前客户端生成一个唯一的随机字符串，然后把该字符串作为锁的value，从而解决这一问题。</p>
<h3 id="版本V3"><a href="#版本V3" class="headerlink" title="版本V3"></a>版本V3</h3><p>在获取锁时，传入的<code>value</code>参数，可以设置为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = UUID.randomUUID().toString()+Thread.currentThread().getId();</span><br></pre></td></tr></table></figure>

<p>解锁的时候，传入该<code>value</code>参数，判断当前锁的值是否和该<code>value</code>参数相同，相同就删除该锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    String lockValue = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(Objects.equals(lockValue,value)) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个释放锁操作分为三个步骤：读取锁的值、比较锁的值、删除锁，三个步骤应该是原子性的，要么都不执行，要么都执行，否则中途某一步没有执行，就会导致释放锁失败。</p>
<p>因此，我们利用Redis的Lua脚本来实现释放锁操作的原子性，Lua脚本内容如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>现在来看释放锁的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用lua脚本进行原子删除操作</span></span><br><span class="line">    String checkAndDelScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(lua, Long.class);</span><br><span class="line">    stringRedisTemplate.execute(redisScript, Collections.singletonList(key), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案是目前最优的<strong>单机Redis</strong>的分布式锁方案，但是在Redis集群环境下依然存在问题：由于Redis集群数据同步为异步，假设在Master节点获取到锁后，数据在同步到Slaver节点前Master节点就崩溃了，那么此时Slaver节点会变成新的Master节点，此时新的Master节点依然可以获取锁，会导致多个Client同时获取到同一个锁。</p>
<h2 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h2><p>针对如何实现Redis集群的分布式锁，国外的分布式专家有过激烈的讨论， Antirez（Redis之父）提出了分布式锁的<strong>Redlock算法</strong>，下面是<strong>Redlock算法</strong>的一个中文说明：</p>
<p>假设有N个独立的Redis master节点：</p>
<p>1、服务器获取当前时间（毫秒数）；</p>
<p>2、按顺序依次向N个Redis节点执行获取锁的操作，这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串<code>value</code>，也包含过期时间(比如PX 30000，即锁的有效时间)。</p>
<p>为了保证在某个Redis节点不可用的时候算法能够继续运行，这个**获取锁的操作还有一个超时时间(time out)**，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。</p>
<blockquote>
<p>这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p>
</blockquote>
<p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去<strong>步骤1</strong>记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p>
<p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去<strong>步骤3</strong>计算出来的获取锁消耗的时间。</p>
<p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p>
<p>6、释放锁：对所有的Redis节点发起释放锁操作。</p>
<p>然而Martin Kleppmann针对这个算法提出了质疑[^1]：</p>
<ul>
<li><p>时钟跳跃：对于Redis服务器如果其时间发生了向跳跃，那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，也会出现client1和client2获取到同一把锁，那么也会出现不安全，这个对于Mysql也会出现。但是ZK（zookepper）由于没有设置过期时间，那么发生跳跃也不会受影响。Redis作者也给出了解答：对于时间跳跃分为人为调整和NTP自动调整。</p>
<ul>
<li>人为调整:人为调整影响的那么完全可以人为不调整，这个是处于可控的。</li>
<li>NTP自动调整:这个可以通过一定的优化，把跳跃时间控制的可控范围内，虽然会跳跃，但是是完全可以接受的。</li>
</ul>
</li>
</ul>
<ul>
<li><p>长时间的GC pause：熟悉Java的同学肯定对GC不陌生，在GC的时候会发生STW(stop-the-world)，例如CMS垃圾回收器，他会有两个阶段进行STW防止引用继续进行变化。那么有可能会出现下面图中这个情况：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="E:\Document\文档\Figures\文档-F-003-03.png" alt="image-20200406232437449" class="lazyload"></p>
<p>client1获取了锁并且设置了锁的超时时间，但是client1之后出现了STW，这个STW时间比较长，导致分布式锁进行了释放，client2获取到了锁，这个时候client1恢复了锁，那么就会出现client1，2同时获取到锁，这个时候分布式锁不安全问题就出现了。这个其实不仅仅局限于RedLock,对于我们的ZK,Mysql一样的有同样的问题。</p>
<p>对于这个问题可以看见基本所有的都会出现问题，Martin给出了一个解法，对于ZK这种他会生成一个自增的序列，那么我们真正进行对资源操作的时候，需要判断当前序列是否是最新，有点类似于我们乐观锁。当然这个解法Redis作者进行了反驳，你既然都能生成一个自增的序列了那么你完全不需要加锁了，也就是可以按照类似于Mysql乐观锁的解法去做。</p>
</li>
<li><p>长时间的网络I/O：这个问题和我们的GC的STW很像，也就是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，这个Mysql也会有，ZK也不会出现这个问题。</p>
</li>
</ul>
<p>对于这三个问题，在网上包括Redis作者在内发起了很多讨论[^1,2,3,4]。</p>
<h2 id="Redisson框架"><a href="#Redisson框架" class="headerlink" title="Redisson框架"></a>Redisson框架</h2><p>前面介绍了基于Redis的分布式锁，以及在Redis集群时使用的Redlock算法，说实话，如果在公司里落地生产环境用分布式锁的时候，一定要尽可能用开源的类库（大佬除外），比如Redis分布式锁，一般就是用<strong>Redisson</strong>框架就好了，它支持redis单实例、redis哨兵、redis cluster、redis master-slave等各种部署架构。</p>
<p>下图简单展示了Redisson对分布式锁的实现原理：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="E:\Document\文档\Figures\文档-F-003-04.png" alt="image-20200412222503408" class="lazyload"></p>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p>当某个客户端要加锁，如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器，然后使用Lua脚本执行原子性的加锁操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                                          <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                                          Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>**KEYS[1]**代表的是加锁的那个key</li>
<li>**ARGV[1]**代表的就是锁key的默认生存时间，默认30秒。</li>
<li>**ARGV[2]**代表的是加锁的客户端的ID</li>
</ul>
<p>通过这个命令设置一个hash数据结构。</p>
<p>实现分布式锁的一个非常重要的点就是set的value要具有唯一性，redisson通过<code>UUID+threadId</code>保证value的唯一性，源码在Redisson.java和RedissonLock.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UUID id = UUID.randomUUID();</span><br><span class="line"><span class="function">String <span class="title">getLockName</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> id + <span class="string">&quot;:&quot;</span> + threadId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="互斥锁机制"><a href="#互斥锁机制" class="headerlink" title="互斥锁机制"></a>互斥锁机制</h4><p>如果在这个时候，客户端2来尝试加锁，执行了同样的一段lua脚本，第一个if判断会执行，发现这个锁key已经存在了。接着第二个if判断，判断锁的key对应的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。所以，客户端2会获取到这个锁key的**剩余生存时间，比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p>
<h4 id="watch-dog自动延期"><a href="#watch-dog自动延期" class="headerlink" title="watch dog自动延期"></a>watch dog自动延期</h4><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>它是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p>
<h4 id="可重入锁即使"><a href="#可重入锁即使" class="headerlink" title="可重入锁即使"></a>可重入锁即使</h4><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？比如下面这种代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">&quot;LockKey&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 业务代码1</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 业务代码2</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>这时我们来分析一下上面那段Lua脚本：</p>
<ul>
<li>第一个if判断肯定不成立，会显示锁key已经存在了；</li>
<li>第二个if判断会成立，因为hash数据结构中包含客户端1的ID；</li>
<li>此时就会执行可重入加锁的逻辑，他会用：<code>redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1)</code>，对客户端1的加锁次数累加1；</li>
</ul>
<p>hash数据结构中的那个客户端ID对应的值，就是该客户端ID的加锁次数。</p>
<h4 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h4><p>如果执行<code>lock.unlock()</code>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line">                                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">                                          Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是每次都对hash数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<code>del</code>命令，从redis里删除这个key，然后客户端2就可以尝试完成加锁了。</p>
<p>这就是<strong>Redisson框架的实现机制</strong>。</p>
<h2 id="游戏学院中的分布式锁"><a href="#游戏学院中的分布式锁" class="headerlink" title="游戏学院中的分布式锁"></a>游戏学院中的分布式锁</h2><p>因为目前游戏学院的系统比较简单，不会出现太复杂的高可用问题，所以目前游戏学院使用的是前文所述的单机Redis分布式锁。</p>
<p>该分布式锁主要用于抽奖活动和投票活动，用于限制用户的抽奖次数、奖品个数、用户剩余票数等。以抽奖为例，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisLock redisLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">getActivityLotteryPrize</span><span class="params">(Long lotteryId, Long userId, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 lockKey 和 lockValue</span></span><br><span class="line">    String lockKey = getLockKey(lotteryId, userId);</span><br><span class="line">    String lockValue = getLockValue(lotteryId, userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!redisLock.tryLock(lockKey, lockValue, Duration.ofMillis(<span class="number">500</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;&gt;(IReturnCode.REFUSE, <span class="string">&quot;当前抽奖人数过多，请稍后重试~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行逻辑操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;&gt;(IReturnCode.SYSTEM_ERROR, IReturnMessage.SYSTEM_ERROR);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisLock.unLock(lockKey, userPrizeKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response.ofSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用抽奖ID（lotteryId）和用户ID（userId）来生成锁的key和value，每个用户剩余抽奖次数都有一个锁，可以保证，即使用户在多个客户端登录，有刷接口行为，同一时刻也只能有一个线程真正地在抽奖。</p>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>本文详细介绍了“基于单机Redis的分布式锁的实现“，从设计的基本原理开始，逐步完善锁的功能，并初步介绍了该实现方案在集群Redis下存在的问题，最后介绍了开源框架Redisson。并没有介绍分布式锁的其他实现方案（比如zookeeper、Spring-integration等[^5]），对于redis分布式锁的性能和优化问题也没有详细介绍[^6]，后面将对这相关问题做进一步的研究。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^1]: <a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a><br>[^2]: <a target="_blank" rel="noopener" href="http://antirez.com/news/101">Is Redlock safe?</a><br>[^3]: <a target="_blank" rel="noopener" href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">基于Redis的分布式锁到底安全吗(上)</a><br>[^4]: <a target="_blank" rel="noopener" href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html">基于Redis的分布式锁到底安全吗(下)</a><br>[^5]: <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Gjnmsx3IbOh3nDfBBAAFgQ">不为人所知的分布式锁实现</a><br>[^6]: <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zlnzgAlarOyZzAKb00Z7Eg">对分布式锁进行高并发优化</a><br>[^7]: <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fdNDHmQJJmiTtrlJY5T8gg">使用Redisson实现分布式锁</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/03/21/hello-world/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="Hello World" class="lazyload">
                    <h1>Hello World</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年03月21日</a>
            <a><i class="nexmoefont icon-areachart"></i>75 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool">
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>
 

<script src="/js/app.js?v=1616312137562"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
